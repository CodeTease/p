use anyhow::{Result, Context};
use std::fs;
use std::path::{Path, PathBuf};
use std::io::Read;
use std::collections::HashMap;

const CACHE_DIR: &str = ".p/cache";

pub fn ensure_cache_setup() -> Result<()> {
    let p_dir = Path::new(".p");
    if !p_dir.exists() {
        fs::create_dir(p_dir).context("Failed to create .p directory")?;
    }
    
    // Create .gitignore inside .p
    let gitignore = p_dir.join(".gitignore");
    if !gitignore.exists() {
        fs::write(&gitignore, "# Generated by Pavidi\n*\n").context("Failed to create .gitignore")?;
    }

    let cache_dir = Path::new(CACHE_DIR);
    if !cache_dir.exists() {
        fs::create_dir_all(cache_dir).context("Failed to create cache directory")?;
    }
    Ok(())
}

fn get_cache_path(task_name: &str) -> PathBuf {
    // Sanitize task name for filename
    let safe_name = task_name.replace(|c: char| !c.is_alphanumeric() && c != '-' && c != '_', "_");
    Path::new(CACHE_DIR).join(format!("{}.hash", safe_name))
}

pub fn compute_hash(sources: &[String], env: &HashMap<String, String>) -> Result<String> {
    let mut hasher = blake3::Hasher::new();
    let mut file_paths = Vec::new();

    for pattern in sources {
        for entry in glob::glob(pattern)? {
            match entry {
                Ok(path) => {
                    if path.is_file() {
                        file_paths.push(path);
                    }
                },
                Err(e) => return Err(anyhow::anyhow!("Glob error: {}", e)),
            }
        }
    }

    // Sort to ensure consistent hash regardless of glob order or filesystem order
    file_paths.sort();

    for path in file_paths {
        // Hash the path itself (so renaming a file changes hash)
        hasher.update(path.to_string_lossy().as_bytes());
        
        let mut file = fs::File::open(&path)?;
        let mut buffer = [0; 4096];
        loop {
            let n = file.read(&mut buffer)?;
            if n == 0 { break; }
            hasher.update(&buffer[..n]);
        }
    }

    // Hash environment variables
    let mut env_keys: Vec<_> = env.keys().collect();
    env_keys.sort();

    for key in env_keys {
        if let Some(val) = env.get(key) {
            hasher.update(key.as_bytes());
            hasher.update(b"=");
            hasher.update(val.as_bytes());
            hasher.update(b"\n");
        }
    }

    Ok(hasher.finalize().to_hex().to_string())
}

pub fn is_up_to_date(task_name: &str, sources: &[String], outputs: &[String], env: &HashMap<String, String>) -> Result<bool> {
    ensure_cache_setup()?;

    // 1. Check if all outputs exist
    for pattern in outputs {
        let mut found_any = false;
        let paths = glob::glob(pattern).context("Failed to glob output")?;
        
        for entry in paths {
            match entry {
                Ok(path) => {
                     // Check if it exists (it should, glob returns existing files)
                     if path.exists() {
                         found_any = true;
                     }
                },
                Err(_) => {} // skip error?
            }
        }
        
        // If a pattern in 'outputs' yields NO files, we consider outputs missing.
        // e.g. outputs=["dist/bundle.js"]. If file missing, glob is empty. found_any=false.
        if !found_any {
             return Ok(false);
        }
    }

    // 2. Check Hash
    let current_hash = compute_hash(sources, env)?;
    let cache_path = get_cache_path(task_name);
    
    if !cache_path.exists() {
        return Ok(false);
    }

    let cached_hash = fs::read_to_string(cache_path)?;
    
    Ok(current_hash.trim() == cached_hash.trim())
}

pub fn save_cache(task_name: &str, sources: &[String], env: &HashMap<String, String>) -> Result<()> {
    ensure_cache_setup()?;
    let current_hash = compute_hash(sources, env)?;
    let cache_path = get_cache_path(task_name);
    fs::write(cache_path, current_hash)?;
    Ok(())
}
